### General Redux introduction

Redux is a predictable state container for JavaScript applications. It provides a way to store a variety of states, such as server responses, cached data, active routes or selected tabs. The redux store saves the states as plain javascript objects, with no setters, or other bits of functionality. To modify the state, an action (javascript object) must be dispatched which will trigger a series of events that update the store, through a reducer. This eliminates the possibility that different parts of the code make changes to the code arbitrarily, which usually result in difficult to identify bugs. 

# Store example

{
    fooBar: [{
        foo: 'bar',
        active: true
    }]
}

# Action example

{
    type: 'TOGGLE_FOOBAR_ACTIVITY',
    active: false
}

# Reducer example

function foobars(state = [], action) {
    if (action.type === 'TOGGLE_FOOBAR_ACTIVITY) {
        return {,
            active: action.active,
            ...state
        }
    }
}

### Store

All the [Store](/app/src/ui/redux/stores/) classes extend from the [StoreBase](/app/src/ui/redux/stores/storeBase.ts) class, or from [DocumentsStoreBase](/app/src/ui/redux/stores/documentsStoreBase.ts) which also extends it. This provides a layer of functionality on top of the redux store. The methods provided by these base classes should be used when writing a new store, when dealing with retreaving or updating the needed state. 

The methods provided by the StoreBase class are: getData(), getEditor(), updateEditor(), deleteEditor(), and resetEditor(). These methods are responsible for dispatching actions that update the state of the application.

To make use of these methods by extending on them, both DataStateKeys and EditorStateKeys need to be updated with a new value corresponding to the newly created store, by adding them in the [dataReducer](/app/src/ui/redux/reducers/dataReducer.ts) and [editorReducer](/app/src/ui/redux/reducers/editorsReducer.ts) objects, accordingly. When writing an extension of one of the previously mentioned methods, it is necessary that these keys are passed down to them as the first argument. The second argument represents the keys for the required parameters of the method. The third argument is the DTOs resulted from an API call.



# Example: 

`/src/ui/redux/reducers/dataReducer.ts`

    export const dataReducer = combineReducers({
        .
        .
        .
        fooBars: dataStoreReducer<FooBarDto[]>("fooBars")
    }

`/src/ui/redux/stores/fooBars.ts`

    export class FooBarStore extends StoreBase{
        .
        .
        .
        public get(id: string){
            return this.getData("fooBar", storeKeys.getIdKey(id), p => ApiClient.fooBars.get({id, ...p}))
        }
        .
        .
        .
    }

### Actions

[Actions](/app/src/ui/redux/actions/) are objects that get passed down onto reducers in order for them to identify what logic must be executed. An action must have a type, but their payload is optional, and actions are generated by the action creator [createAction](/app/src/ui/redux/actions/common/createAction.ts). This action creator is overloaded to take either a single parameter (the type), or two parameters (the type and the payload), and based on the given arguments, the return type can be either of the type [IAction](/app/src/ui/redux/actions/common/createAction.ts) or [IActionWithPayload](/app/src/ui/redux/actions/common/createAction.ts). 

Once you have created a method that returns an action, you can invoke this method and pass it down as an argument to the store's dispatch method. (e.g. store.dispatch(Actions.initaliseAction());)

# Example: 

`/src/ui/redux/actions/fooBar.ts`
    // Action without payload
    export type FooBarAction = ReturnType<typeof fooBar>;
    export const fooBar = () => createAction("FOO_BAR");

    //
    export type FooBarWithPayloadAction = ReturnType<typeof fooBarWithPayload>;
    export const fooBarWithPayload = (payload: FooBarDto) => createAction("FOO_BAR", payload);

### Middleware

[Middleware](/app/src/ui/redux/middleware/) is used on this project as a way to chain additional series of events between the dispatching of an action, and the moment it reaches the reducer. This can be useful for logging states, debugging, crash reporting, routing, and other additional logic. 
Middleware is prepared with the [setupMiddleware](/app/src/ui/redux/middleware.ts)  method, which bundles all middleware methods, based on the router passed down, and, given that some middlewares cannot be used on the server, a check is performed on the *isClient* boolean to identify if a specific middleware needs to be applied, and if it is not applicable, then a noop middleware (a middleware with the sole purpose of executing the next middleware) is applied instead.
The [setupMiddleware](/app/src/ui/redux/middleware.ts) method is invoked in the [client.tsx] and [serverRender.tsx] files, where it gets applied to the redux store as a passed down argument to the [createStore] redux method. 

# Example:

`/src/ui/redux/middleware/loggingMiddleware.ts`

    export const loggingMiddleware = (store: MiddlewareAPI<Dispatch, RootState>) => (next: Dispatch) => (action: AnyAction) => {
    console.log("Running action", action.type, action.payload);
    next(action);
    };


### Reducers

[Reducers](/app/src/ui/redux/reducers) package, and are bits of functionality that update the state of a store based on the type of action they receive. A reducer takes the current state of the store and an action, and filters out the action's type to identify what logic to perform. If the action's type is not defined, the reducer should just reduce the state. The newly created reducer needs to be added to the [rootReducer](/app/src/ui/redux/reducers/rootReducer.ts) object, and the [RootState](/app/src/ui/redux/reducers/rootReducer.ts) interface needs to be updated accordingly.

# Example

`/src/ui/redux/reducers/fooBarReducer.ts`

    export interface FooBarState{
        fooBar: string
    }

    export const fooBarRedcer = (state: FooBarState, action: FooBarAction) {
        if (action.type === "UPDATE_FOO_BAR){
            return {
                ...state,
                fooBar: action.payload.fooBar
            }
        }
    }

`/src/ui/redux/reducers/rootReducer.ts`

    export interface RootState {
        .
        .
        .
        fooBar: FooBarState
    }

    export const rootReducer = combineReducers<RootState>({
        .
        .
        .
        fooBar: fooBarReducer
    });


### Selectores

[Selectors](/app/src/ui/redux/selectors/) are functions that accept Redux state as an argument and return data that is derived from that state. They compute derived data and allow Redux to store the minimal possible state, increasing the efficiency of the application.
